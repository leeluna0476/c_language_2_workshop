# C언어(2) 소모임 - 정기 (11주차)
## 포인터변수란?
포인터변수... 일반 변수와 뭐가 다른가?

변수가 뭘까?
- 메모리 공간에 이름을 붙인 것.
- 이름은 컴파일 후 전부 사라진다. C언어 레벨에서만 존재...
- 변수가 **메모리 공간 그 자체**라고 볼 수도 있다.
- `int a;` int 크기만큼의 메모리 공간.

- `int * p = &a;`
- p는 a라는 공간을 가리킨다.
- p 또한 **변수**다.
- p 또한 **어떤 메모리 공간**이다.

- 메모리 공간이라는 관점에서는 p, a 둘 다 같다.
- 이 공간에 저장되는 값을 **어떻게 해석할지**가 이 둘의 차이를 결정한다.
- p는 **포인터**변수, 다시 말해 **주소** 변수. 저장된 값을 **주소**로 해석한다.
- `int *p = 1;`, `int a = 1;`
- 둘의 차이는?

## 정적 메모리 공간과 동적 메모리 공간
|구분|정적|동적|
|---|---|---|
|크기 결정 시점|실행 전. 컴파일 시점.|실행 중. 메모리 할당 함수를 호출하는 시점.|
|생성 시점|실행 중. 소스에서 변수 선언을 명시한대로.|실행 중. 메모리 할당 함수를 호출하는 시점.|
|소멸 시점|실행 중. 변수가 속한 스코프가 끝나는 시점.|실행 중. 프로그램 종료 직전 또는 명시적 free 호출 시점.|

1. int 변수 하나만큼의 공간을 가리킨다. (sint 가리키는 게 아님 주의.)
```c
#include <stdlib.h> // to use malloc

int main(void) {
    int sint;
    int *dint = malloc(sizeof(int));
    free(dint);
}
```
```c
// 적법하지 않은 방식.
// 문법적으로는 OK.
// goo가 반환된 후로부터 a는 더 이상 보호받지 않는 메모리. => 변수 X.
int *goo() {
    int a = 12;
    return &a;
}

// 적법한 방식.
int *foo() {
    int *a = malloc(sizeof(int)); // 확보한 공간의 주소를 반환.
    a[0] = 12; // a[0] == *(a + 0) == *a 완전히 동일한 표현...
    return a;
}

int main() {
    int * p = foo();
    printf("%d\n", *p); // 무엇이 출력?
    free(p);
}
```
동적 메모리를 쓰면 변수의 수명을 내 맘대로 결정할 수 있다.

2. int 4개짜리의 공간을 가리킨다. (배열과 같음. sarr1 가리키는 게 아님 주의.)
```c
    int sarr1[4];
    int *darr1 = malloc(sizeof(int) * 4);
    // 둘 다 16바이트 공간이다...
```


3. int 2 * 3 == 6개만큼의 공간을 가리키나?
sarr2와 darr2는, 위 sint dint, sarr1 darr1과 같이 서로 구조가 완벽히 같은가?
```c
int sarr2[2][3];

//int **darr2 = malloc(sizeof(int) * 2 * 3); // ???
int **darr2 = malloc(sizeof(int *) * 2);
darr2[0] = malloc(sizeof(int) * 3);
darr2[1] = malloc(sizeof(int) * 3);
```

## 2중 포인터란?
- 포인터변수 => 주소를 저장하는 변수.
- 2중포인터변수 => 역시 주소를 저장하는 변수.
```c
// 1중 포인터.
int *p = &a;
//p변수에 a변수 주소 저장.
//저장된 그 값을 주소로 해석하여 그 공간으로 이동하고, 그 공간에 쓰인 값을 읽어오는 게 `*p`라는 문법.
// p == &a
//*p == a

// 2중 포인터.
int **p2 = &p;
// p2 == &p
// *p2 == p == &a
// **p2 == *p == a
//p2 변수에 p변수 주소 저장.
//저장된 값을 주소로 해석하여 그 공간으로 이동.
//이동해서 얻은 값 == p에 저장된 값.
//이 값을 한번 더 주소로 해석하여 그 공간으로 이동.
//이렇게 두번 이동하여 얻은 값이 a에 저장된 값.

int b;
*p2 = &b;
// p == &b
// p2가 가리키는 공간에 b의 주소를 저장했는데, p에 저장된 주소가 바뀌었다.
// 그야 p2가 가리키는 그 공간이 바로 p의 공간이기 때문.
// 반대로도 가능하겠지?
```

## 미션
1. `dyarr`라는 이름으로 동적 배열을 만들어라.
  - `int arr[20];`와 정확히 동일한 구조의 동적 배열.
<!--
**[solution]**
```c
// solution 1.
int *dyarr = malloc(80);

// solution 2.
// sizeof()... 연산자... 변수나 타입의 크기 알려준다.
// 가독성 better. 그리고 가끔 sizeof(int)가 4가 아닌 경우가 있다.
// 우리 수업 환경에서는 결과적으로는 완전히 동일하다.
int *dyarr = malloc(sizeof(int) * 20);
```
-->

2. `int b = 42;`
  - 이중 포인터 p2를 가지고, b에 저장된 42라는 값을 출력하는 프로그램을 만드시오.

3. `int arr[2][3] = { {1, 2, 3}, {4, 5, 6} };`
  - 이 배열과 논리적으로 동일한 구조의 동적 배열을 만드시오.
<!--
**[solution]**
```c
int **ptr = malloc(sizeof(int *) * 2);
ptr[0] = malloc(sizeof(int) * 3);
ptr[1] = malloc(sizeof(int) * 3);
```
***[REMEMBER]***
```
*(ptr + 0) == ptr[0]
*(ptr + 1) == ptr[1]
```
-->

4. `int arr[2][3][4];` 숙제.
  - 이 배열과 논리적으로 동일한 구조의 동적 배열을 만드시오.
